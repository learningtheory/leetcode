/*
<p>Given a non negative integer number <b>num</b>. For every numbers <b>i</b> in the range <b>0 &le; i &le; num</b> calculate the number of 1's in their binary representation and return them as an array.
</p>
<p>
<b>Example:</b></br>
For <code>num = 5</code> you should return <code>[0,1,1,2,1,2]</code>.
</p>
<p>
<b>Follow up:</b>
<ul>
<li>It is very easy to come up with a solution with run time <b>O(n*sizeof(integer))</b>. But can you do it in linear time <b>O(n)</b> /possibly in a single pass?</li>
<li>Space complexity should be <b>O(n)</b>.</li>
<li>Can you do it like a boss? Do it without using any builtin function like <b>__builtin_popcount</b>  in c++ or in any other language.</li>
</ul>
</p>

<p><b>Credits:</b><br />Special thanks to <a href="https://leetcode.com/discuss/user/syedee">@ syedee </a> for adding this problem and creating all test cases.</p><p>给定一个非负整数&nbsp;<strong>num</strong>。 对于范围&nbsp;<strong>0 &le; i &le; num&nbsp;</strong>中的每个数字&nbsp;<strong>i&nbsp;</strong>，计算其二进制数中的1的数目并将它们作为数组返回。</p>

<p><strong>示例：</strong><br />
比如给定&nbsp;<code>num = 5</code>&nbsp;，应该返回&nbsp;<code>[0,1,1,2,1,2]</code>.</p>

<p><strong>进阶：</strong></p>

<ul>
	<li>给出时间复杂度为<strong>O(n * sizeof(integer)) </strong>的解答非常容易。 但是你可以在线性时间<strong>O(n)</strong>内用一次遍历做到吗？</li>
	<li>要求算法的空间复杂度为<strong>O(n)</strong>。</li>
	<li>你能进一步完善解法吗？ 在c ++或任何其他语言中不使用任何内置函数（如c++里的&nbsp;<strong>__builtin_popcount</strong>）来执行此操作。</li>
</ul>

<p><strong>致谢：</strong><br />
特别感谢&nbsp;<a href="https://leetcode.com/discuss/user/syedee">@syedee </a> 添加此问题及所有测试用例。</p>
<p>给定一个非负整数&nbsp;<strong>num</strong>。 对于范围&nbsp;<strong>0 &le; i &le; num&nbsp;</strong>中的每个数字&nbsp;<strong>i&nbsp;</strong>，计算其二进制数中的1的数目并将它们作为数组返回。</p>

<p><strong>示例：</strong><br />
比如给定&nbsp;<code>num = 5</code>&nbsp;，应该返回&nbsp;<code>[0,1,1,2,1,2]</code>.</p>

<p><strong>进阶：</strong></p>

<ul>
	<li>给出时间复杂度为<strong>O(n * sizeof(integer)) </strong>的解答非常容易。 但是你可以在线性时间<strong>O(n)</strong>内用一次遍历做到吗？</li>
	<li>要求算法的空间复杂度为<strong>O(n)</strong>。</li>
	<li>你能进一步完善解法吗？ 在c ++或任何其他语言中不使用任何内置函数（如c++里的&nbsp;<strong>__builtin_popcount</strong>）来执行此操作。</li>
</ul>

<p><strong>致谢：</strong><br />
特别感谢&nbsp;<a href="https://leetcode.com/discuss/user/syedee">@syedee </a> 添加此问题及所有测试用例。</p>
*/


/**
 * Return an array of size *returnSize.
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* countBits(int num, int* returnSize) {
    
}