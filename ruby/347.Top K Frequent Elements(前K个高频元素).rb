=begin
<p>
Given a non-empty array of integers, return the <b><i>k</i></b> most frequent elements.</p>

<p>For example,<br>
Given <code>[1,1,1,2,2,3]</code> and k = 2, return <code>[1,2]</code>.
</p>

<p><b>Note: </b><br>
<ul>
<li>You may assume <i>k</i> is always valid, 1 &le; <i>k</i> &le; number of unique elements.</li>
<li>Your algorithm's time complexity <b>must be</b> better than O(<i>n</i> log <i>n</i>), where <i>n</i> is the array's size.</li>
</ul></p><p>给定一个非空的整数数组，返回其中出现频率前&nbsp;<strong><em>k&nbsp;</em></strong>高的元素。</p>

<p>例如，</p>

<p>给定数组&nbsp;<code>[1,1,1,2,2,3]</code> , 和 k = 2，返回&nbsp;<code>[1,2]</code>。</p>

<p><strong>注意：</strong></p>

<ul>
	<li>你可以假设给定的&nbsp;<em>k&nbsp;</em>总是合理的，1 &le; k &le; 数组中不相同的元素的个数。</li>
	<li>你的算法的时间复杂度<strong>必须</strong>优于 O(<em>n</em> log <em>n</em>) , <em>n&nbsp;</em>是数组的大小。</li>
</ul>
<p>给定一个非空的整数数组，返回其中出现频率前&nbsp;<strong><em>k&nbsp;</em></strong>高的元素。</p>

<p>例如，</p>

<p>给定数组&nbsp;<code>[1,1,1,2,2,3]</code> , 和 k = 2，返回&nbsp;<code>[1,2]</code>。</p>

<p><strong>注意：</strong></p>

<ul>
	<li>你可以假设给定的&nbsp;<em>k&nbsp;</em>总是合理的，1 &le; k &le; 数组中不相同的元素的个数。</li>
	<li>你的算法的时间复杂度<strong>必须</strong>优于 O(<em>n</em> log <em>n</em>) , <em>n&nbsp;</em>是数组的大小。</li>
</ul>

=end


# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer[]}
def top_k_frequent(nums, k)
    
end